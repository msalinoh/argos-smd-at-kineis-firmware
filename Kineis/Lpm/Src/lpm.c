// SPDX-License-Identifier: no SPDX license
/**
 * @file    lpm.c
 * @brief   This file contains some utilities and functions needed for a correct handling of LPM
 *          on the STM32WL55xx cortex M4 core
 *          This file conatins the
 *
 *          This code is provided as an example by Kineis and is free to modifications as per
 *          integrator, application needs.
 * @author  Kineis
 */

/**
 * @addtogroup MGR_LPM
 * @{
 */

/* Includes ------------------------------------------------------------------------------------ */
#include <stdbool.h>

#include "main.h"
#include "usart.h"

#include "lpm.h"
#include "mgr_lpm.h"
#include "lpm_cli_kstk.h"
#include "mgr_log.h"

#pragma GCC visibility push(default)

/* Defines -------------------------------------------------------------------*/
#if defined(STM32WLE5xx) || defined(STM32WL55xx)
#define USART_ISR_RXNE USART_ISR_RXNE_RXFNE
#endif

/* Types --------------------------------------------------------------------------------------- */

/**
 * @brief structure containing context to backup during LPM.
 *
 * So far it is used to store the current LPM mode.
 *
 * @attention the 32-bit word storing the mow power mode must fitt the low power manager's structure
 * regarding low_power_mode parameter (\ref MgrLpm_ctxt_t)
 */
struct LPM_retentionReg_t {
	/** BKP0R register: 4 lower bits must follow MgrLpm_ctxt_t struct */
	__IO uint32_t reserved             : 28;
	__IO uint32_t low_power_mode       :  4; /**< current low power mode
						   * should follow MgrLpm_LPM_t enum
						   */
	/** BKP1R register */
	// \todo uncomment following lines to add data in next register
	//__IO uint32_t reserved    : 32;
};

/* Private functions prototypes ---------------------------------------------------------------- */

/** Function prototypes defined before variable as referenced in lpm_config variable */
static void LPM_sleep_enter();
static void LPM_sleep_exit();
static void LPM_stop_enter();
static void LPM_stop_exit();
static void LPM_standby_enter();
#ifdef LPM_SHUTDOWN_ENABLED
static void LPM_shutdown_enter();
#endif

/* Variables ----------------------------------------------------------------------------------- */

__attribute__((__section__(".retentionRamData")))
struct MgrLpm_EnvConfig_t lpm_config = {
	.allowedLPMbitmap  = LOW_POWER_MODE_NONE
#if defined(LPM_SLEEP_ENABLED)
			     | LOW_POWER_MODE_SLEEP
#elif defined(LPM_STOP_ENABLED)
			     | LOW_POWER_MODE_SLEEP | LOW_POWER_MODE_STOP
#elif defined(LPM_STANDBY_ENABLED)
			     | LOW_POWER_MODE_SLEEP | LOW_POWER_MODE_STOP | LOW_POWER_MODE_STANDBY
#elif defined(LPM_SHUTDOWN_ENABLED)
			     | LOW_POWER_MODE_SLEEP | LOW_POWER_MODE_STOP | LOW_POWER_MODE_STANDBY
			     | LOW_POWER_MODE_SHUTDOWN
#endif
			     ,
	.fp_sleep_enter    = LPM_sleep_enter,
	.fp_sleep_exit     = LPM_sleep_exit,
	.fp_stop_enter     = LPM_stop_enter,
	.fp_stop_exit      = LPM_stop_exit,
	.fp_standby_enter  = LPM_standby_enter,
#ifdef LPM_SHUTDOWN_ENABLED
	.fp_shutdown_enter = LPM_shutdown_enter
#else
	.fp_shutdown_enter = NULL
#endif
};

__attribute__((__section__(".lpmSection")))
struct LPM_retentionReg_t lpm_ctxt = {
	.low_power_mode = LOW_POWER_MODE_NONE
};

/* Private functions --------------------------------------------------------------------------- */

static bool LPM_configWakeUpUart(void)
{
	/* make sure that no UART transfer is on-going */
	/* make sure that UART is ready to receive
	 * (test carried out again later in HAL_UARTEx_StopModeWakeUpSourceConfig)
	 */
	while ((__HAL_UART_GET_FLAG(&hlpuart1, USART_ISR_BUSY) == SET) ||
		(__HAL_UART_GET_FLAG(&hlpuart1, USART_ISR_RXNE) == SET) ||
		(__HAL_UART_GET_FLAG(&hlpuart1, USART_ISR_REACK) == RESET))
		;

	/* set the UART wake-up event:
	 * specify wake-up on start-bit detection
	 */
	UART_WakeUpTypeDef WakeUpSelection;

	WakeUpSelection.WakeUpEvent = UART_WAKEUP_ON_READDATA_NONEMPTY;
	if (HAL_UARTEx_StopModeWakeUpSourceConfig(&hlpuart1, WakeUpSelection)
			!= HAL_OK)
		return false;

	/* Enable the UART Wake UP from STOP mode Interrupt */
	__HAL_UART_ENABLE_IT(&hlpuart1, UART_IT_WUF);

	/* enable MCU wake-up by UART */
	HAL_UARTEx_EnableStopMode(&hlpuart1);

	return true;
}


/** @brief System Clock Configuration when exit from stop mode
 *
 * @note This function is inspired from SystemClock_Config Core function generated by STM32CubeMX
 *       in main.c. This version is trying to retreive original configuration instead of direct
 *       duplication.
 */
static void LPM_SystemClock_Config_RestoreFromStop(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  uint32_t pFLatency = 0;

  /* Enable Power Control clock */
#if defined(STM32WLE5xx) || defined(STM32WL55xx)
  HAL_PWR_EnableBkUpAccess();
#else
  __HAL_RCC_PWR_CLK_ENABLE();
#endif

  /* Get the Oscillators configuration according to the internal RCC registers */
  HAL_RCC_GetOscConfig(&RCC_OscInitStruct);

  /* After wake-up from Stop reconfigure the system clock: Enable HSI and PLL */
  RCC_OscInitStruct.OscillatorType  = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.HSIState        = RCC_HSI_ON;
  RCC_OscInitStruct.PLL.PLLState    = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource   = RCC_PLLSOURCE_HSI;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /* Get the Clocks configuration according to the internal RCC registers */
  HAL_RCC_GetClockConfig(&RCC_ClkInitStruct, &pFLatency);

  /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2
   * clocks dividers
   */
  RCC_ClkInitStruct.ClockType     = RCC_CLOCKTYPE_SYSCLK;
  RCC_ClkInitStruct.SYSCLKSource  = RCC_SYSCLKSOURCE_PLLCLK;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, pFLatency) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
 * @brief Function used to configure the external wakeup pins to exit low power mode (standby and
 *        shutdown only)
 *
 * @note So far, it is coded to exit standby or shutdown only.
 * @note So far, the wakeup pin is directly hardcoded in the core fo this function:
 *       * WKUP2 (PC13, blue user button) falling edge.
 *
 * @todo Need to add input parameter to make it generic regarding the wakeup pins configuration.
 */
static void LPM_configWakeUpPins(void)
{
	/* Disable all wakeup first */
	HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN1);
	HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN2);
	HAL_PWR_DisableWakeUpPin(PWR_WAKEUP_PIN3);

	/* clear all wakeup flags in status register */
	__HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);

	/* But enable wakeup with:
	 * * falling edge on wakeup pin 2, i.e. PC13,  user blue button
	 * Pressing the user button will exit from shutdown mode.
	 */
	HAL_PWR_EnableWakeUpPin(PWR_WAKEUP_PIN3_HIGH);
}

/**
 * @brief Function used to configure the internal wakeup line to exit low power mode
 *
 * @note So far, our internal line needs is RTC alarms and wakeup timer
 */
static void LPM_configWakeUpRtc(void)
{

#if defined(STM32L476xx) || defined(STM32WLE5xx) || defined(STM32WL55xx)
	HAL_PWREx_DisableInternalWakeUpLine();

	/* clear wakeup flags in status register */
	__HAL_PWR_CLEAR_FLAG(PWR_FLAG_WUFI);

	/* But enable wakeup with:
	 * * internal line (RTC alarm, wakup timer)
	 */
	HAL_PWREx_EnableInternalWakeUpLine();
#endif
}

/** @brief System callback invoked by MGR_LPM at SLEEP mode entering */
static void LPM_sleep_enter() {
//	MGR_LOG_DEBUG("==== SLEEP enter ====\r\n");
	HAL_SuspendTick();
	/** force renabling interrupt as wakeup from UART is needed */
	__enable_fault_irq();
	__enable_irq();
}

/** @brief System callback invoked by MGR_LPM at SLEEP mode exit */
static void LPM_sleep_exit() {
	HAL_ResumeTick();
//	MGR_LOG_DEBUG("==== SLEEP exit ====\r\n");
}

/** @brief System callback invoked by MGR_LPM at STOP mode entering */
static void LPM_stop_enter() {
//	MGR_LOG_DEBUG("==== STOP enter ====\r\n");
	GPIO_DisableAllToAnalogInput();
	/** Configure and renable interrupt as wakeup from UART is needed in case of GUI APP.
	 *
	 * @attention, This should not be done in case of standalone APP, as long as UART reception
	 * is not is fully configured (need to call UART_Start_Receive_IT or KINEIS_UART_StartRx_IT
	 * at init)
	 *
	 * */
	LPM_configWakeUpUart();
	__enable_fault_irq();
	__enable_irq();
}

/** @brief System callback invoked by MGR_LPM at STOP mode exit */
static void LPM_stop_exit() {
	/* Wake Up on start bit detection successful */
	LPM_SystemClock_Config_RestoreFromStop();
	HAL_UARTEx_DisableStopMode(&hlpuart1);
	HAL_Delay(100); /** So far need to add some delay at exit before being able to receive a new
			 * AT command from UART link.
			 * @note same delay used in STM32 examples
			 */
//	MGR_LOG_DEBUG("==== STOP exit ====\r\n");
}

/** @brief System callback invoked by MGR_LPM at STANDBY mode entering */
static void LPM_standby_enter() {
	MGR_LOG_DEBUG("==== STANDBY enter ====\r\n");

	GPIO_DisableAllToAnalogInput();
	HAL_PWREx_EnablePullUpPullDownConfig();
	/** Force pull down on wakeup pin: PB3, or PC13 or PA0 */
	HAL_PWREx_EnableGPIOPullDown(PWR_GPIO_B, PWR_GPIO_BIT_3);

#if defined(STM32WL55xx)
	HAL_PWREx_EnableSRAMRetention();
#else
	HAL_PWREx_EnableSRAM2ContentRetention();
#endif
	LPM_configWakeUpRtc();
	LPM_configWakeUpPins();
	__HAL_RCC_CLEAR_RESET_FLAGS();

	/** Disable all peripherals before going to STANDBY LPM. As STDBY exit leads to reset of the
	 * uC, all peripherals will be restarted through normal wake-up sequence (cf main fct).
	 *
	 * @note RTC peripheral must remain ON in LPM, as it is in charge to exit LPM for
	 * periodic transmission or at SAT pass start and end.
	 *
	 * @note Only RX line of UART is disabled. Disabling UART peripheral entirely may leads to
	 * instabilities if not correctly disabled on host side as well. Refer to HAL_UART_MspDeInit
	 * for details about DeInit sequence
	 */
	// disable UART interrupt and RX GPIO
	HAL_GPIO_DeInit(GPIOA, GPIO_PIN_3);
	HAL_NVIC_DisableIRQ(LPUART1_IRQn);
}

#ifdef LPM_SHUTDOWN_ENABLED
/** @brief System callback invoked by MGR_LPM at STANDBY mode entering */
static void LPM_shutdown_enter() {
	MGR_LOG_DEBUG("==== SHUTDOWN enter ====\r\n");

	GPIO_DisableAllToAnalogInput();
	HAL_PWREx_EnablePullUpPullDownConfig();
	/** Force pull down on wakeup pin: PB3, or PC13 or PA0 */
	HAL_PWREx_EnableGPIOPullDown(PWR_GPIO_B, PWR_GPIO_BIT_3);

	LPM_configWakeUpRtc();
	LPM_configWakeUpPins();
	__HAL_RCC_CLEAR_RESET_FLAGS();
}
#endif

/* Functions ----------------------------------------------------------------------------------- */

void LPM_SystemClockConfig(void)
{
	/* =================== SHUTDOWN/STANDBY support ============================= */
	/* Enable Power Clock */
#if defined(STM32WLE5xx) || defined(STM32WL55xx)
	HAL_PWR_EnableBkUpAccess();
#else
	__HAL_RCC_PWR_CLK_ENABLE();
#endif

	/* =================== SLEEP/STOP support ============================= */
	/* Disable Prefetch Buffer */
	__HAL_FLASH_PREFETCH_BUFFER_DISABLE();
	/* Reset all RCC Clock-enable in Sleep and Stop modes but LPTIM1 and LPUART in a way to
	 * improve current drain.
	 */
	/* \note: sounds like no official HAL API exists to configure clock sleep */
	RCC->AHB1SMENR  = 0x0;
	RCC->AHB2SMENR  = 0x0;
	RCC->AHB3SMENR  = 0x0;
	RCC->APB1SMENR1 = 0x0;
	RCC->APB1SMENR2 = 0x0;
	RCC->APB2SMENR  = 0x0;
//	__HAL_RCC_LPTIM1_CLK_SLEEP_ENABLE();
	__HAL_RCC_LPUART1_CLK_SLEEP_ENABLE();
	__HAL_RCC_RTCAPB_CLK_SLEEP_ENABLE();


	/* =================== STOP support ============================= */
	/* Configure the wake up from stop clock, back to full speed HSI. From System clock MUX,
	 * full speed should be back as well then.
	 */
//	__HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_HSI);
	HAL_RCCEx_WakeUpStopCLKConfig(RCC_STOP_WAKEUPCLOCK_HSI);
	/* =============================================================== */
}

void GPIO_DisableAllToAnalogInput(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = PA_PSU_EN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* Disable GPIOs clock */
  __HAL_RCC_GPIOA_CLK_DISABLE();
}

void LPM_init(void)
{
	MGR_LPM_init(lpm_config);
	MGR_LPM_registerClient(mgrLpmCliKstk);
}

void LPM_enter(void)
{
	MGR_LPM_enter(lpm_config, (struct MgrLpm_ctxt_t *)&lpm_ctxt);

}
void LPM_forceMode(enum MgrLpm_LPM_t low_power_mode)
{
	lpm_ctxt.low_power_mode = low_power_mode;
}

inline enum MgrLpm_LPM_t LPM_getMode(void)
{
	return (enum MgrLpm_LPM_t) lpm_ctxt.low_power_mode;
}
#pragma GCC visibility pop

/**
 * @}
 */
